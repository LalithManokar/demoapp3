{"version":3,"sources":["webpack:///XLSXExportUtils.js","webpack:///webpack/bootstrap f8e83bbf539da40b9b2e","webpack:///./client/src/export-utils.js","webpack:///./client/src/provider/ODataDataProvider.js","webpack:///./client/src/provider/RequestHandler.js","webpack:///./client/src/filesaver/FileSaver.js"],"names":["XLSXExportUtils","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","36","ODataDataProvider","FileSaver","oData","fetch","requestData","getConverter","saveFile","37","getValue","oRow","oCol","keys","reduce","obj","key","convertData","aRows","aCols","forEach","col","row","getColsToConvert","mSettings","workbook","columns","result","properties","Array","unitProperty","push","aKeys","split","length","type","getDataConverter","aColumns","processDataUrl","sDataUrl","iSkip","iTop","mDataUrl","reSkip","reTop","URI","parse","query","test","serialize","build","fnProcessCallback","getUrl","sNextUrl","mNextUrl","dataUrl","replace","fnOnError","sMessage","error","fnOnDataReceived","oResult","aData","iFetchedRows","fPercent","iRemainingRows","mCallbackParams","bCancelled","value","results","isArray","iAvailableRows","iTotalRows","finished","progress","Math","round","__next","mRequest","min","iBatchSize","RequestHandler","sendRequest","then","catch","rows","fnConvertData","mDataSource","dataSource","count","MAX_ROWS","sizeLimit","batchSize","serviceUrl","url","mUri","path","slice","hash","fragment","method","useBatch","headers","cancel","38","oRequest","Error","sendBatchRequest","sendGetRequest","Promise","fnResolve","fnReject","sHeaderKey","xhr","XMLHttpRequest","onload","this","status","responseText","JSON","e","HTTP_WRONG_RESPONSE_MSG","onerror","HTTP_ERROR_MSG","onabort","open","setRequestHeader","toLowerCase","send","createGuid","r","random","toString","sKey","sValue","boundary","body","aLines","iEnd","iLength","iStart","oResponseData","join","39","blob","link","downloadSupported","fnSave","Blob","document","createElementNS","data","fileName","download","href","URL","createObjectURL","dispatchEvent","MouseEvent","reader","FileReader","onloadend","opened","window","location","readAsDataURL","navigator","msSaveOrOpenBlob"],"mappings":"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","file":"XLSXExportUtils.js","sourcesContent":["var XLSXExportUtils =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 36);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 36:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Bundle all utilities into a single module\nvar ODataDataProvider = __webpack_require__(37);\nvar FileSaver = __webpack_require__(39);\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n/***/ }),\n\n/***/ 37:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar RequestHandler = __webpack_require__(38);\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed.\r\n *\r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @returns {number|string|boolean} - The converted property value\r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\r\n\t// Get property value\r\n\tvar value = oCol.keys.reduce(function(obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n *\r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * @returns {Array} - An array of rows\r\n *\r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function(col) {\r\n\t\taRows.forEach(function(row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n * E.g. handling data from association/navigationProperty\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @returns {Array} - Collection of columns that need special conversion for their values\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\r\n\t\tvar properties;\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\r\n\t\t// Handle unitPoperty which too could be from an association\r\n\t\tif (col.unitProperty) {\r\n\t\t\tproperties.push(col.unitProperty);\r\n\t\t}\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split('/');\r\n\r\n\t\t\tif (aKeys.length > 1) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\r\n *\r\n * @param {string} sDataUrl\r\n * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n * @param {number} iTop - The amount of items that should be requested with this query\r\n * @returns {string} processed data URL\r\n */\r\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\r\n\tvar mDataUrl, reSkip = /\\$skip\\=[0-9]+/, reTop = /\\$top\\=[0-9]+/;\r\n\r\n\tif (!sDataUrl) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tmDataUrl = URI.parse(sDataUrl);\r\n\r\n\tmDataUrl.query = mDataUrl.query || '';\r\n\t// Add missing $skip if needed\r\n\tif (!reSkip.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\r\n\t}\r\n\t// Add missing $top if needed\r\n\tif (!reTop.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += '&$top=' + iTop;\r\n\t}\r\n\r\n\treturn (URI.serialize || URI.build)(mDataUrl);\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\r\n * @returns {Object} - Object reference that allows to cancel the current processing\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\t/**\r\n\t * Nested function to remove not used information from the URL\r\n\t *\r\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\r\n\t * @returns {string} - A clean URL\r\n\t */\r\n\tfunction cleanUrl(url) {\r\n\t\tvar mUri;\r\n\r\n\t\tif (!url) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tmUri = URI.parse(url);\r\n\r\n\t\tmUri.path = mUri.path || '';\r\n\t\tif (mUri.path.slice(-1) !== '/') {\r\n\t\t\tmUri.path = mUri.path + '/';\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates the download URL for the next query.\r\n\t *\r\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n\t * @param {number} iTop - The amount of items that should be requested with this query\r\n\t * @param {string} sNextUrl - A reference to the next bulk of data that was returned by the previous request\r\n\t * @returns {string} - The URL for the next query\r\n\t */\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl, mNextUrl;\r\n\r\n\t\tmDataUrl = URI.parse(dataUrl);\r\n\r\n\t\t/*\r\n\t\t * Use $skiptoken from response to query the next items.\r\n\t\t * OData V4 returns a relative path, while OData V2 returns\r\n\t\t * an absolute path. Therefore we need to use the original\r\n\t\t * URL to keep possible proxy settings and avoid any issues\r\n\t\t * between OData V4 and V2\r\n\t\t */\r\n\t\tif (sNextUrl) {\r\n\t\t\tmNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // Use $skip and $top\r\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\r\n\t\t\t\t.replace(/\\$skip\\=[0-9]+/g, '$skip=' + iSkip)\r\n\t\t\t\t.replace(/\\$top\\=[0-9]+/g, '$top=' + iTop);\r\n\t\t}\r\n\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // Cancelled by the application\r\n\t\t}\r\n\r\n\t\t/* Check for OData V4 result, if not present check for OData V2 result or apply default */\r\n\t\taData = (oResult && oResult.value || (oResult.d && (oResult.d.results || oResult.d))) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// Check if next url is provided\r\n\t\tsNextUrl = (oResult && oResult['@odata.nextLink'] || (oResult.d && oResult.d.__next)) || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn { cancel: function() { bCancelled = true; } };\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n/***/ }),\n\n/***/ 38:\n/***/ (function(module, exports) {\n\n/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\n/**\n * Creates and sends a GET request to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar sHeaderKey;\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.onload = function() {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open('GET', oRequest.dataUrl, true);\n\t\txhr.setRequestHeader('accept', 'application/json');\n\n\t\t/* Set custom header information on the request as well as on the batch request */\n\t\tfor (sHeaderKey in oRequest.headers) {\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\n\t\t\t}\n\t\t}\n\n\t\txhr.send();\n\t});\n}\n\n/**\n * Creates a pseudo random GUID. This algorithm is not suitable for\n * cryptographic purposes and should not be used therefore.\n *\n * @returns {string} - Generated GUID\n */\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\n\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Creates a $batch request and sends it to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = 'batch_' + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\t\tvar sKey, sValue;\n\n\t\txhr.onload = function() {\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\n\n\t\t\tresponseText = this.responseText;\n\t\t\taLines = this.responseText.split('\\r\\n');\n\n\t\t\t// TBD: check return codes\n\t\t\tiStart = 0;\n\t\t\tiLength = aLines.length;\n\t\t\tiEnd = iLength - 1;\n\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\n\t\t\t\tiStart++;\n\t\t\t}\n\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join('\\r\\n');\n\n\t\t\ttry {\n\t\t\t\toResponseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(oResponseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\n\t\t// Create request\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\n\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\n\n\t\tbody.push('--' + boundary);\n\t\tbody.push('Content-Type: application/http');\n\t\tbody.push('Content-Transfer-Encoding: binary');\n\t\tbody.push('');\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\n\n\t\t/* Set header information on the request as well as on the batch request */\n\t\tfor (sKey in oRequest.headers) {\n\t\t\tsValue = oRequest.headers[sKey];\n\n\t\t\tif (sKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\n\t\t\t}\n\t\t\tbody.push(sKey + ':' + sValue);\n\t\t}\n\n\t\tbody.push('');\n\t\tbody.push('');\n\t\tbody.push('--' + boundary + '--');\n\t\tbody.push('');\n\t\tbody = body.join('\\r\\n');\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n/***/ }),\n\n/***/ 39:\n/***/ (function(module, exports) {\n\n/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function(data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t};\n\t}\n\n\t/* In case of iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function(data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function() {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t};\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function(data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// XLSXExportUtils.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 36);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f8e83bbf539da40b9b2e","// Bundle all utilities into a single module\nvar ODataDataProvider = require('./provider/ODataDataProvider.js');\nvar FileSaver = require('./filesaver/FileSaver.js');\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/export-utils.js\n// module id = 36\n// module chunks = 1","var RequestHandler = require('./RequestHandler.js');\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed.\r\n *\r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @returns {number|string|boolean} - The converted property value\r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\r\n\t// Get property value\r\n\tvar value = oCol.keys.reduce(function(obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n *\r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * @returns {Array} - An array of rows\r\n *\r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function(col) {\r\n\t\taRows.forEach(function(row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n * E.g. handling data from association/navigationProperty\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @returns {Array} - Collection of columns that need special conversion for their values\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\r\n\t\tvar properties;\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\r\n\t\t// Handle unitPoperty which too could be from an association\r\n\t\tif (col.unitProperty) {\r\n\t\t\tproperties.push(col.unitProperty);\r\n\t\t}\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split('/');\r\n\r\n\t\t\tif (aKeys.length > 1) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\r\n *\r\n * @param {string} sDataUrl\r\n * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n * @param {number} iTop - The amount of items that should be requested with this query\r\n * @returns {string} processed data URL\r\n */\r\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\r\n\tvar mDataUrl, reSkip = /\\$skip\\=[0-9]+/, reTop = /\\$top\\=[0-9]+/;\r\n\r\n\tif (!sDataUrl) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tmDataUrl = URI.parse(sDataUrl);\r\n\r\n\tmDataUrl.query = mDataUrl.query || '';\r\n\t// Add missing $skip if needed\r\n\tif (!reSkip.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\r\n\t}\r\n\t// Add missing $top if needed\r\n\tif (!reTop.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += '&$top=' + iTop;\r\n\t}\r\n\r\n\treturn (URI.serialize || URI.build)(mDataUrl);\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\r\n * @returns {Object} - Object reference that allows to cancel the current processing\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\t/**\r\n\t * Nested function to remove not used information from the URL\r\n\t *\r\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\r\n\t * @returns {string} - A clean URL\r\n\t */\r\n\tfunction cleanUrl(url) {\r\n\t\tvar mUri;\r\n\r\n\t\tif (!url) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tmUri = URI.parse(url);\r\n\r\n\t\tmUri.path = mUri.path || '';\r\n\t\tif (mUri.path.slice(-1) !== '/') {\r\n\t\t\tmUri.path = mUri.path + '/';\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates the download URL for the next query.\r\n\t *\r\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n\t * @param {number} iTop - The amount of items that should be requested with this query\r\n\t * @param {string} sNextUrl - A reference to the next bulk of data that was returned by the previous request\r\n\t * @returns {string} - The URL for the next query\r\n\t */\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl, mNextUrl;\r\n\r\n\t\tmDataUrl = URI.parse(dataUrl);\r\n\r\n\t\t/*\r\n\t\t * Use $skiptoken from response to query the next items.\r\n\t\t * OData V4 returns a relative path, while OData V2 returns\r\n\t\t * an absolute path. Therefore we need to use the original\r\n\t\t * URL to keep possible proxy settings and avoid any issues\r\n\t\t * between OData V4 and V2\r\n\t\t */\r\n\t\tif (sNextUrl) {\r\n\t\t\tmNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // Use $skip and $top\r\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\r\n\t\t\t\t.replace(/\\$skip\\=[0-9]+/g, '$skip=' + iSkip)\r\n\t\t\t\t.replace(/\\$top\\=[0-9]+/g, '$top=' + iTop);\r\n\t\t}\r\n\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // Cancelled by the application\r\n\t\t}\r\n\r\n\t\t/* Check for OData V4 result, if not present check for OData V2 result or apply default */\r\n\t\taData = (oResult && oResult.value || (oResult.d && (oResult.d.results || oResult.d))) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// Check if next url is provided\r\n\t\tsNextUrl = (oResult && oResult['@odata.nextLink'] || (oResult.d && oResult.d.__next)) || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn { cancel: function() { bCancelled = true; } };\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/ODataDataProvider.js\n// module id = 37\n// module chunks = 1","/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\n/**\n * Creates and sends a GET request to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar sHeaderKey;\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.onload = function() {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open('GET', oRequest.dataUrl, true);\n\t\txhr.setRequestHeader('accept', 'application/json');\n\n\t\t/* Set custom header information on the request as well as on the batch request */\n\t\tfor (sHeaderKey in oRequest.headers) {\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\n\t\t\t}\n\t\t}\n\n\t\txhr.send();\n\t});\n}\n\n/**\n * Creates a pseudo random GUID. This algorithm is not suitable for\n * cryptographic purposes and should not be used therefore.\n *\n * @returns {string} - Generated GUID\n */\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\n\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Creates a $batch request and sends it to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = 'batch_' + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\t\tvar sKey, sValue;\n\n\t\txhr.onload = function() {\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\n\n\t\t\tresponseText = this.responseText;\n\t\t\taLines = this.responseText.split('\\r\\n');\n\n\t\t\t// TBD: check return codes\n\t\t\tiStart = 0;\n\t\t\tiLength = aLines.length;\n\t\t\tiEnd = iLength - 1;\n\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\n\t\t\t\tiStart++;\n\t\t\t}\n\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join('\\r\\n');\n\n\t\t\ttry {\n\t\t\t\toResponseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(oResponseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\n\t\t// Create request\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\n\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\n\n\t\tbody.push('--' + boundary);\n\t\tbody.push('Content-Type: application/http');\n\t\tbody.push('Content-Transfer-Encoding: binary');\n\t\tbody.push('');\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\n\n\t\t/* Set header information on the request as well as on the batch request */\n\t\tfor (sKey in oRequest.headers) {\n\t\t\tsValue = oRequest.headers[sKey];\n\n\t\t\tif (sKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\n\t\t\t}\n\t\t\tbody.push(sKey + ':' + sValue);\n\t\t}\n\n\t\tbody.push('');\n\t\tbody.push('');\n\t\tbody.push('--' + boundary + '--');\n\t\tbody.push('');\n\t\tbody = body.join('\\r\\n');\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/RequestHandler.js\n// module id = 38\n// module chunks = 1","/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function(data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t};\n\t}\n\n\t/* In case of iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function(data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function() {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t};\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function(data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/filesaver/FileSaver.js\n// module id = 39\n// module chunks = 1"],"sourceRoot":""}