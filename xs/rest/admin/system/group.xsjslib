const trace = $.import("sap.ino.xs.xslib", "trace");
const message = $.import("sap.ino.xs.aof.lib","message");

const whoAmI = "sap.ino.xs.rest.admin.system.group.xsjslib";
const debug = function debug(line) {
    trace.debug(whoAmI, line);
};

const AOF = $.import("sap.ino.xs.aof.core", "framework");
const Group = AOF.getApplicationObject("sap.ino.xs.object.iam.Group");
const SourceTypeCode = $.import("sap.ino.xs.object.iam", "SourceTypeCode");
const GroupLib = $.import("sap.ino.xs.object.iam", "Group");
const oHQ = $.import("sap.ino.xs.xslib", "dbConnection").getHQ();

const util = $.import("sap.ino.xs.rest.admin.system", "util");
const toObjectArray     = util.toObjectArray;
const toCSVResponse     = util.toCSVResponse;
const mergeMessages     = util.mergeMessages;
const mergeMessage      = util.mergeMessage;
const containsError     = util.containsError;
const sequenceExecution = util.sequenceExecution;

var fullHeader = ['OPERATION', 'NAME',
                  'MESSAGE', 'TYPE', 'REF_FIELD',
                  'PARAM_0', 'PARAM_1', 'PARAM_2', 'PARAM_3'];

// ALTER is is somewhat pointless if groups only have a name
// it servers as a "no operation" token in order to facilitate
// autogenerated full upload requests
var executableOperations = ['CREATE', 'ALTER', 'DROP'];

const createSingleGroup = function(oRow) {
    return sequenceExecution(oRow, 'CREATED', [Group.create]);
};

const alterSingleGroup = function(oRow) {
    return sequenceExecution(oRow, 'ALTERED', [Group.update]);
};

const dropSingleGroup = function(oRow) {
    return sequenceExecution(oRow, 'DROPPED', [
        function (oRow){ return Group.del(oRow.ID); }
    ]);
};


function process(input) {
    GroupLib.setBatchMode();
    message.createMessage(message.MessageSeverity.Info, "MSG_GROUP_UPLOAD");

    // parse input and find out if full upload is required
    var parsedInput = toObjectArray(input, fullHeader);

    // detect duplicate input entries, create a hashmap for backwards mapping
    var rowByGroupName = {};
    (function () {
        for (var row=0; row < parsedInput.length; ++row) {
            var operation = parsedInput[row].OPERATION || "";
            if (executableOperations.indexOf(operation) >= 0) {
                if (rowByGroupName[parsedInput[row].NAME] === undefined) {
                    rowByGroupName[parsedInput[row].NAME] = row;
                } else {
                    parsedInput[row] = mergeMessage(parsedInput[row], 'E', 'MSG_GROUP_UPLOAD_DUPLICATE_GROUP_NAME', 'GROUP_NAME');
                    // instead of removing the row and merging it in later on, we flag it accordingly
                    parsedInput[row].skipped = true;
                }
            }
        }
    }());

    // read sap.ino.db.iam::v_identity to determine the proper identity IDs for those that do exist
    // and put the result into a hashmap
    var identities = oHQ.statement('select ID, NAME from "sap.ino.db.iam::v_identity" where TYPE_CODE = \'GROUP\'').execute();
    var idByGroupName = {};
    var i;
    for (i=0; i<identities.length; ++i) {
        idByGroupName[identities[i].NAME] = identities[i].ID;
    }

    // map full upload to delta upload
    if (parsedInput.fullUpload) {
        // in case of full upload mode determine the operations
        // CREATE for new groups
        // ALTER for existing groups
        for (i=0; i<parsedInput.length; ++i) {
            parsedInput[i].OPERATION = idByGroupName[parsedInput[i].NAME] === undefined? 'CREATE': 'ALTER';
        }
    }

    // distribute by operation type
    var result = [];
    for (var rowIndex=0; rowIndex < parsedInput.length; ++rowIndex) {
        var row = parsedInput[rowIndex];
        if (row.skipped) {
            result.push(row);
        } else {
            switch (row.OPERATION) {
                case 'CREATE':
                    var preliminaryId = -1;
                    row.ID = preliminaryId--;
                    row.SOURCE_TYPE_CODE = SourceTypeCode.SourceTypeCode.Upload;
                    result.push(createSingleGroup(row));
                    break;
                case 'ALTER':
                    if (idByGroupName[row.NAME] === undefined) {
                        row = mergeMessage(row, 'E', 'MSG_GROUP_UPLOAD_GROUP_NOT_FOUND', 'NAME');
                        result.push(row);
                    } else {
                        row.ID = idByGroupName[row.NAME];
                        row.SOURCE_TYPE_CODE = SourceTypeCode.SourceTypeCode.Upload;
                        result.push(alterSingleGroup(row));
                    }
                    break;
                case 'DROP':
                    if (idByGroupName[row.NAME] === undefined) {
                     // we assume that a drop for something that does not exist is some kind of success
                        row = mergeMessage(row, 'S', 'MSG_GROUP_UPLOAD_GROUP_NOT_FOUND', 'NAME');
                        row.OPERATION = 'DROPPED';
                        result.push(row);
                    } else {
                        row.ID = idByGroupName[row.NAME];
                        result.push(dropSingleGroup(row));
                    }
                    break;
            }
        }
    }
    
    // in case of full upload add the missing DELETE operations to the result
    if (parsedInput.fullUpload) {
        for (i=0; i<identities.length; ++i) {
            var deleteRequestRow = {OPERATION: 'DROP'};
            if (rowByGroupName[identities[i].NAME] === undefined) {
                // NAME not contained in input
                deleteRequestRow.NAME = identities[i].NAME;
                deleteRequestRow = mergeMessage(deleteRequestRow, 'E', 'MSG_GROUP_UPLOAD_NO_IMPLICIT_DROP', 'NAME');
                result.push(deleteRequestRow);
            }
        }
    }

    GroupLib.finalizeBatchMode(oHQ);

    return (
        "This service is DEPRECATED, please use the new service /sap/ino/xs/rest/admin/system/group_upload.xsjs instead\n" +
        toCSVResponse(result, fullHeader)
    );
}

